package comp1110.ass2;

import comp1110.ass2.gui.Game;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

import java.util.Arrays;

public class Tile {
    /**
     * Tile identification.
     *     1. Every tile is created with a name of A#, B# or S#, connecting with its .png file in the directory gui/assets.
     *     2. When a tile is generated by random dice roll, it has a default orientation of 0 but no position.
     *     3. When a tile is validly placed into the tile board, it gets it position and update the current orientation and placement string.
     *
     * Consistence for edge status and direction.
     */
    public String name;
    public String pos;
    char orientation;

    int graphId;  // Default is 0, but -1 for tile B; it will be greater than 0 if assigned to a graph.

    // Used to label edge graph id for tile B.
    int upId;
    int rightId;
    int downId;
    int leftId;

    static final int BLANK = 0;
    static final int RAIL = 1;
    static final int HIGH = 2;

    static final int UP = 0;
    static final int RIGHT = 1;
    static final int DOWN = 2;
    static final int LEFT = 3;

    /**
     * This 15*4 matrix represents original edge status of each die in default orientation.
     * Route types:
     *     Special tiles (S0-5);
     *     Railways (A0-2);
     *     Highways (A3-5);
     *     Stations (B0-1).
     *
     * Two offset consistence is used to locate the index for an individual tile.
     *
     * Each row represents a individual tile with 4 edge status.
     * Each column of data follows the order of up, right, down and left.
     */
    private static final int TILE_A_INDEX_OFFSET = 6;
    private static final int TILE_B_INDEX_OFFSET = 12;
    private static final int[][] ORIGIN_EDGE_STATUS = {
            //S0 original shape
            {HIGH, HIGH, RAIL, HIGH},
            //S1 original Shape
            {HIGH, RAIL, RAIL, RAIL},
            //S2 original Shape
            {HIGH, HIGH, HIGH, HIGH},
            //S3 original Shape
            {RAIL, RAIL, RAIL, RAIL},
            //S4 original Shape
            {HIGH, RAIL, RAIL, HIGH},
            //S5 original Shape
            {HIGH, RAIL, HIGH, RAIL},

            //A0 original Shape
            {RAIL, BLANK, BLANK, RAIL},
            //A1 original Shape
            {RAIL, BLANK, RAIL, BLANK},
            //A2 original Shape
            {RAIL, RAIL, RAIL, BLANK},
            //A3 original Shape
            {HIGH, HIGH, HIGH, BLANK},
            //A4 original Shape
            {HIGH, BLANK, HIGH, BLANK},
            //A5 original Shape
            {HIGH, BLANK, BLANK, HIGH},

            //B0 original Shape
            {HIGH, BLANK, RAIL, BLANK},
            //B1 original Shape
            {HIGH, RAIL, BLANK, BLANK},
            //B2 original Shape
            {HIGH, RAIL, HIGH, RAIL}
    };

    private ImageView imgView;
    public double imgLayoutX, imgLayoutY;
    public double deltaX, deltaY;

    public Tile(String str) {
        if (str.contains(".png")) {
            // Using file directory assets/XX.png to create a new instance for image view.
            name = str.substring(7, 9);
            pos = "  ";
            orientation = '0';
            Image image = new Image(Game.class.getResource(str).toString());
            this.imgView = new ImageView(image);
        } else {
            // Create a new instance with tile placement string.
            name = str.substring(0, 2);
            pos = str.substring(2, 4);
            orientation = str.charAt(4);
        }

        // Special graph id for B2 tile.
        if (this.name.equals("B2")) {
            graphId = -1;
        }
    }

    public void setImgView(ImageView img) {
        this.imgView = img;
    }
    public ImageView getImgView() {
        return this.imgView;
    }

    /**
     * Rotate this tile clockwise by 90 degrees.
     *    A rotation 90° shift the value of orientation from the left to the right:
     *    [0, 1, 2, 3] --> [1, 2, 3, 0]
     *    [4, 5, 6, 7] --> [5, 6, 7, 4]
     *
     * @author Wyman
     */
    public void rotate90Degree() {
        // Save the flag for the original status.
        boolean flag = isMirrorOverY();

        this.orientation += 1;
        if (flag && this.orientation > '7') {
            this.orientation -= 4;
        }
        if (!flag && this.orientation > '3') {
            this.orientation -= 4;
        }
    }

    /**
     * Rotate this tile clockwise by 270 degrees.
     *    A rotation 270° shift the value of orientation from the left to the right:
     *    [0, 1, 2, 3] --> [3, 0, 1, 2]
     *    [4, 5, 6, 7] --> [7, 4, 5, 6]
     *
     * @author Wyman
     */
    public void rotate270Degree() {
        rotate90Degree();
        rotate90Degree();
        rotate90Degree();
    }

    /**
     * Flipping the tile across the y axis.
     * Orientation mapping:
     *     0 <-> 4
     *     1 <-> 7
     *     2 <-> 6
     *     3 <-> 5
     *
     * @author Wyman
     */
    public void flipOverY() {
        char[] mapping = {'4', '7', '6', '5', '0', '3', '2', '1'};
        this.orientation = mapping[this.orientation - '0'];
    }

    /**
     * Get the row number for the current tile.
     * A reflection from 'A'-'G' to 0-6.
     *     'A' --> 0; 'B' --> 1; 'C' --> 2; 'D' --> 3
     *     'E' --> 4; 'F' --> 5; 'G' --> 6
     *
     * @author Wyman
     * @return the row number for this tile in the tile board.
     */
    public int getRowPos() {
        return pos.charAt(0) - 'A';
    }

    /**
     * Get the column number for the current tile.
     * The number will be from 0 to 6.
     *
     * @author Wyman
     * @return the column number for this tile in the tile board.
     */
    public int getColPos() {
        return pos.charAt(1) - '0';
    }

    /**
     * Check whether the current orientation is the result from mirroring over the y-axis.
     * Tiles may be rotated, or flipped across the x or y axis.
     * Altogether there are eight orientations:
     *     1. Orientation 0 is the starting state.
     *     2. Orientations 1, 2, and 3 represent rotations of 90, 180, and 270 degrees clockwise, respectively.
     *     3. Orientation 4 is created by mirroring orientation 0 over the y-axis.
     *     4. Orientations 5, 6, and 7 are rotated 90-270 degrees clockwise from orientation 4.
     *
     * @author Wyman
     * @return true if this tile is flipped across the y axis (4 <= orientation <= 7).
     */
    boolean isMirrorOverY() {
        return orientation > '3';
    }

    /**
     * 0-3: At original status, rotate of 90 degrees for 0 time, once, twice and three times, respectively.
     * 4-7: After flipping over y-axis, rotate of 90 degrees for 0 time, once, twice and three times, respectively.
     *
     * (This method is often used after calling isMirrorOverY().)
     *
     * @author Senyuan
     *
     * @return the number of times for which the tile rotates 90 degrees from origin or mirroring over the y-axis.
     */
    public int getOrientation() {
        char tmpOri = orientation;
        if (isMirrorOverY()) {
            tmpOri -= 4;
        }
        return tmpOri - '0';
    }

    /**
     * Get the index of for its specific type for this tile.
     * S0-5: index 0  - index 5;
     * A0-5: index 6  - index 11;
     * B0-2: index 12 - index 14.
     *
     * @author Senyuan
     * @return the index of for its specific type for this tile.
     */
    int getTileIdx() {
        if (name.charAt(0) == 'S') {
            return name.charAt(1) - '0';
        } else if (name.charAt(0) == 'A') {
            return name.charAt(1) - '0' + TILE_A_INDEX_OFFSET;
        } else {
            return name.charAt(1) - '0' + TILE_B_INDEX_OFFSET;
        }
    }

    /**
     * Get the current status of tile's edges with orientation known.
     *
     * @author Wyman and Senyuan
     * @return a vector representing the current edge status in the order of UP, RIGHT, DOWN and LEFT.
     */
    int[] getCurrentEdgesStatus() {
        int tileIdx = getTileIdx();
        int tileOri = getOrientation();

        int tmpEdgeStatus;
        int[] curEdgeStatus = Arrays.copyOf(ORIGIN_EDGE_STATUS[tileIdx], ORIGIN_EDGE_STATUS[tileIdx].length);

        if (isMirrorOverY()){
            tmpEdgeStatus = curEdgeStatus[RIGHT];
            curEdgeStatus[RIGHT] = curEdgeStatus[LEFT];
            curEdgeStatus[LEFT] = tmpEdgeStatus;
        }

        for (int i = 0; i < tileOri; i++){
            tmpEdgeStatus = curEdgeStatus[UP];
            curEdgeStatus[UP] = curEdgeStatus[LEFT];
            curEdgeStatus[LEFT] = curEdgeStatus[DOWN];
            curEdgeStatus[DOWN] = curEdgeStatus[RIGHT];
            curEdgeStatus[RIGHT] = tmpEdgeStatus;
        }

        return curEdgeStatus;
    }

    /**
     * Place image view referring to its orientation.
     *
     * @author Wyman
     */
    public void placeImgView() {
        // Set image view to default status.
        imgView.setRotate(0);
        imgView.setScaleX(1);

        if (this.isMirrorOverY()) {
            imgView.setScaleX(-1);
        }
        imgView.setRotate(90 * (this.getOrientation()));
    }

    /**
     * Get the whole placement string including name of tile, position in the board and the orientation.
     *
     * @return placement string.
     */
    public String getPlacementStr() {
        return name + pos + orientation;
    }
}
